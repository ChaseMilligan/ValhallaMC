<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Shop | ValhallaMC SMP</title>
  <meta name="description" content="ValhallaMC SMP v2 — Shop" />
  <link rel="icon" href="server-icon.png" type="image/png">
  <link rel="stylesheet" href="./style.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:ital,wght@0,200..800;1,200..800&family=Stack+Sans+Notch:wght@200..700&family=Zalando+Sans+Expanded:ital,wght@0,200..900;1,200..900&display=swap"
    rel="stylesheet">

  <!-- Tebex.js -->
  <script defer src="https://js.tebex.io/v/1.js"></script>
  <script src='https://storage.ko-fi.com/cdn/scripts/overlay-widget.js'></script>
  <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.1.0/dist/markdown-it.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/markdown-it-attrs@4.3.1/markdown-it-attrs.browser.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/markdown-it-container@4.0.0/dist/markdown-it-container.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/markdown-it-link-attributes@4.0.1/dist/markdown-it-link-attributes.min.js"></script>
</head>

<body>
  <iframe class="video-bg" width="1920" height="1080" allow="autoplay"
    src="https://www.youtube.com/embed/7CouiWXWKLY?si=ZnllnfbVE8V5K_NX&amp;controls=0&autoplay=1&loop=1&mute=1&playlist=7CouiWXWKLY"
    title="YouTube video player" frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; loop;"
    referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

  <div class="wrap">
    <script>
      fetch('components/navigation.html')
        .then(response => response.text())
        .then(data => {
          const element = document.createElement('div');
          element.classList.add('navigation');
          document.querySelector('.wrap').insertAdjacentElement('afterbegin', element);
          element.innerHTML = data;

          const scripts = element.querySelectorAll('script');
          scripts.forEach(oldScript => {
            const newScript = document.createElement('script');
            Array.from(oldScript.attributes).forEach(attr =>
              newScript.setAttribute(attr.name, attr.value)
            );
            newScript.appendChild(document.createTextNode(oldScript.innerHTML));
            oldScript.parentNode.replaceChild(newScript, oldScript);
          });
        });
    </script>
  </div>  

  <div id="above-the-fold">
    <div id="server-status" style="height: auto;">
      <div class="wrap" style="height: auto;padding-bottom:0!important;">
        <div class="ip" style="height: auto;">
          <h2>Welcome to the ValhallaMC Shop</h2>
          <p class="muted warn">The shop is currently under development and may have limited features. If any problems should
            arise, please contact <a href="mailto:support@valhallamc.ca">support</a>.</p>
          <p class="muted">Browse and purchase in-game packages to enhance your Minecraft experience on ValhallaMC SMP.</p>
          <p class="muted">Your purchases support the ongoing development and maintenance of the server.</p>
          <!-- CART / CHECKOUT -->
          <div id="cart-panel">
            <div class="row" style="width: 100%;align-items: start;">
              <div class="col-6" style="align-items: start;">
                <h2>Checkout Info</h2>
                <p class="muted">Enter your Minecraft username, add packages, adjust quantities, then checkout.</p>
                <div class="field-row" style="align-items: start;">
                  <div class="field"  style="align-items: start;">
                    <small class="muted">Minecraft username</small>
                    <div class="row">
                      <input id="mc-username" class="input" placeholder="e.g. MrOzoskiniki" autocomplete="off" />
                      <button id="btn-new-basket" class="btn" type="button">New Basket</button>
                    </div>
                    <small id="basket-status" class="muted">Basket: not created</small>
                  </div>
                </div>
              </div>
              <div class="col-6" style="align-items: start;height:100%;">
                <div class="row between" style="width: 100%; align-items: center; margin-top: 8px;">
                  <h2>Cart (<span class="total-item-count">0</span>)</h2>
                  
                </div>
                <div class="cart-list card" id="cart-list" style="align-items: start;"></div>
                <div class="row between" style="width: 100%;">
                  <div class="row">
                    <div class="muted" style="margin-bottom: 0;">Total</div>
                    <div id="cart-total" class="cart-total">—</div>
                  </div>
                  <div class="row between" style="width: 100%; align-items: center; margin-top: 8px;">
                    <p class="muted" style="text-align:right;width:100%;" id="cart-hint">Add something to your cart to enable checkout.</p>
                    <button id="btn-checkout" class="btn" type="button" style="border-color: var(--accent2);"><small>Checkout</small></button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="output" id="below-the-fold">
    <div class="wrap">
      <!-- PRODUCTS -->
      <div class="product-grid" id="product-grid"></div>
    </div>
  </div>
</div>

<script>
  fetch('/get-token')
    .then(response => response.text())
    .then(token => {
      // ============================================================
    // Tebex Headless + Tebex.js (single-page, no backend)
    // ============================================================


    const STORE_TOKEN = token;
    const API_BASE = `https://headless.tebex.io/api/accounts/${STORE_TOKEN}`;

    const LS_KEYS = {
      basketIdent: "tebex_basket_ident",
      usernameId: "tebex_username_id",
      username: "tebex_username"
    };

    const state = {
      basketIdent: localStorage.getItem(LS_KEYS.basketIdent) || "",
      usernameId: localStorage.getItem(LS_KEYS.usernameId) || "",
      username: localStorage.getItem(LS_KEYS.username) || ""
    };

    const qtyUpdateTimers = new Map(); // packageId -> timeout id

    const $ = (id) => document.getElementById(id);

    function saveState() {
      localStorage.setItem(LS_KEYS.basketIdent, state.basketIdent || "");
      localStorage.setItem(LS_KEYS.usernameId, state.usernameId || "");
      localStorage.setItem(LS_KEYS.username, state.username || "");
    }

    function setStatus(msg) {
      $("basket-status").textContent = msg;
    }

    function safeText(htmlMaybe) {
      if (!htmlMaybe) return "";
      const div = document.createElement("div");
      div.innerHTML = htmlMaybe;
      return (div.textContent || div.innerText || "").trim();
    }

    function formatMoney(amount, currency) {
      if (amount == null) return "—";
      const num = typeof amount === "string" ? Number(amount) : amount;
      if (!Number.isFinite(num)) {
        // Sometimes basket.price is already formatted string
        if (typeof amount === "string" && amount.trim().length) return amount;
        return "—";
      }
      try {
        return new Intl.NumberFormat(undefined, { style: "currency", currency: currency || "USD" }).format(num);
      } catch {
        return `${num.toFixed(2)} ${currency || ""}`.trim();
      }
    }

    function pickPackagePrice(pkg) {
      // Best-effort, varies by config.
      const candidates = [
        pkg?.total_price,
        pkg?.price,
        pkg?.base_price,
        pkg?.price_with_tax
      ];

      for (const c of candidates) {
        if (c && typeof c === "object" && (c.amount != null || c.value != null)) {
          return { amount: c.amount ?? c.value, currency: c.currency ?? c.currency_code };
        }
        if (typeof c === "number") return { amount: c, currency: pkg?.currency || pkg?.currency_code };
        if (typeof c === "string" && c.trim() && !Number.isNaN(Number(c))) return { amount: Number(c), currency: pkg?.currency || pkg?.currency_code };
      }

      const p0 = pkg?.prices?.[0];
      if (p0 && (p0.amount != null || p0.value != null)) {
        return { amount: p0.amount ?? p0.value, currency: p0.currency ?? p0.currency_code };
      }

      return null;
    }

    async function apiJson(url, options = {}) {
      const res = await fetch(url, {
        headers: {
          "Accept": "application/json",
          ...(options.body ? { "Content-Type": "application/json" } : {}),
          ...(options.headers || {})
        },
        ...options
      });

      const text = await res.text();
      let json = null;
      try { json = text ? JSON.parse(text) : null; } catch { /* ignore */ }

      if (!res.ok) {
        const msg = json?.message || json?.error || text || `HTTP ${res.status}`;
        throw new Error(msg);
      }
      return json;
    }

    function clearBasketLocal() {
      state.basketIdent = "";
      state.usernameId = "";
      saveState();
      setStatus("Basket: not created");
      renderCart(null);
    }

    async function fetchBasket() {
      if (!state.basketIdent) return null;
      const url = `${API_BASE}/baskets/${encodeURIComponent(state.basketIdent)}`;
      const data = await apiJson(url);
      return data?.data || data;
    }

    async function createBasket(forceUsername) {
      const username = (forceUsername ?? state.username ?? "").trim();
      if (!username) throw new Error("Enter your Minecraft username first.");

      const body = {
        complete_url: `${location.origin}${location.pathname}?thanks=1`,
        cancel_url: location.href,
        complete_auto_redirect: false,
        username
      };

      const url = `${API_BASE}/baskets`;
      const res = await apiJson(url, { method: "POST", body: JSON.stringify(body) });

      const basket = res?.data || res;
      const ident = basket?.ident || basket?.basketIdent || basket?.basket_ident;
      const usernameId = basket?.username_id || basket?.usernameId || basket?.username_ident;

      if (!ident) throw new Error("Basket created but ident was missing in response.");

      state.basketIdent = ident;
      state.usernameId = usernameId || "";
      state.username = username;
      saveState();

      setStatus(`Basket: ${state.basketIdent}${state.usernameId ? ` (user linked)` : ""}`);
      return basket;
    }

    async function ensureBasket() {
      const inputUsername = $("mc-username").value.trim();
      if (inputUsername && inputUsername !== state.username) {
        clearBasketLocal();
        state.username = inputUsername;
        saveState();
      } else if (!state.username && inputUsername) {
        state.username = inputUsername;
        saveState();
      }

      if (!state.basketIdent) {
        return await createBasket(state.username);
      }

      try {
        const basket = await fetchBasket();
        // refresh username_id if it appears later
        const uid = basket?.username_id || basket?.usernameId || "";
        if (uid && uid !== state.usernameId) {
          state.usernameId = uid;
          saveState();
        }
        setStatus(`Basket: ${state.basketIdent}${state.usernameId ? ` (user linked)` : ""}`);
        return basket;
      } catch {
        clearBasketLocal();
        return await createBasket(state.username);
      }
    }

    async function getAuthOptions() {
      if (!state.basketIdent) return null;
      const returnUrl = encodeURIComponent(location.href);
      const url = `${API_BASE}/baskets/${encodeURIComponent(state.basketIdent)}/auth?returnUrl=${returnUrl}`;
      try {
        const authOptions = await apiJson(url);
        if (Array.isArray(authOptions) && authOptions.length) return authOptions;
      } catch {
        // Some store types may not use auth endpoint
      }
      return null;
    }

    async function authorizeBasket() {
      await ensureBasket();
      const options = await getAuthOptions();
      if (!options) {
        alert("No authorization options were returned for this basket/store type.");
        return;
      }
      const first = options[0];
      if (first?.url) {
        location.href = first.url; // will return to returnUrl
      } else {
        alert("Auth option did not include a URL.");
      }
    }

    async function addPackageToBasket(packageId) {
      const basket = await ensureBasket();

      const payload = {
        package_id: Number(packageId),
        quantity: 1
      };

      // Game server command stores may require username_id in variable_data
      const usernameId = state.usernameId || basket?.username_id || basket?.usernameId;
      if (usernameId) {
        payload.variable_data = { username_id: usernameId };
      }

      const url = `https://headless.tebex.io/api/baskets/${encodeURIComponent(state.basketIdent)}/packages`;
      await apiJson(url, { method: "POST", body: JSON.stringify(payload) });

      const totalItems = normalizeCartItems(basket).reduce((sum, it) => sum + it.qty, 0);
      document.querySelector(".total-item-count").textContent = String(totalItems);
      await refreshCart();
    }

    async function removePackageFromBasket(packageId) {
      if (!state.basketIdent) return;
      const url = `https://headless.tebex.io/api/baskets/${encodeURIComponent(state.basketIdent)}/packages/remove`;
      await apiJson(url, { method: "POST", body: JSON.stringify({ package_id: Number(packageId) }) });
      await refreshCart();

      const totalItems = normalizeCartItems(await fetchBasket()).reduce((sum, it) => sum + it.qty, 0);
      document.querySelector(".total-item-count").textContent = String(totalItems);
    }

    async function updatePackageQuantity(packageId, quantity) {
      if (!state.basketIdent) return;
      const q = Math.max(1, Math.min(99, Number(quantity) || 1));

      // Quantity update endpoint (may require auth)
      const url = `https://headless.tebex.io/api/baskets/${encodeURIComponent(state.basketIdent)}/packages/${encodeURIComponent(packageId)}`;

      try {
        await apiJson(url, { method: "PUT", body: JSON.stringify({ quantity: q }) });
        await refreshCart();
      } catch (e) {
        // If store requires auth before quantity updates, push user to authorize
        showAuthWarn(true);
        const msg = (e && e.message) ? e.message : String(e);
        alert(`Quantity update failed.\n\n${msg}\n\nIf this store requires authorization, click "Authorize" and try again.`);
        throw e;
      }
    }

    function extractBasketTotal(basket) {
      if (!basket) return { amount: null, currency: null };

      const currency = basket.currency || basket.currency_code || basket.currencyCode || null;

      // Many responses include basket.price as a string (docs show it) or number
      if (basket.total_price != null) {
        // could be formatted or numeric string; formatMoney handles both
        return { amount: basket.total_price, currency };
      }

      // Some shapes include total_price.amount
      const tp = basket.total_price || basket.totalPrice;
      if (tp && typeof tp === "object" && (tp.amount != null || tp.value != null)) {
        return { amount: tp.amount ?? tp.value, currency: tp.currency ?? tp.currency_code ?? currency };
      }

      // Fallback: sum packages if we can
      const items = basket.packages || basket.items || [];
      let sum = 0;
      let ok = false;

      for (const it of items) {
        const qty = Number(it.qty ?? it.quantity ?? 1);
        const p = it.price || it.total_price || it.base_price || it.unit_price || null;

        let amt = null;
        if (p && typeof p === "object") amt = p.amount ?? p.value ?? null;
        else if (typeof p === "number") amt = p;
        else if (typeof p === "string" && !Number.isNaN(Number(p))) amt = Number(p);

        if (amt != null && Number.isFinite(amt) && Number.isFinite(qty)) {
          sum += amt; // note: sometimes this already includes qty. can't know reliably.
          ok = true;
        }
      }

      return { amount: ok ? sum : null, currency };
    }

    function normalizeCartItems(basket) {
      // Tebex basket uses packages array (docs) but some responses may differ
      const items = basket?.packages || basket?.items || [];
      return items.map((it) => {
        const id = it.id ?? it.package_id ?? it.packageId ?? it.package?.id;
        const name = it.name ?? it.package?.name ?? "Item";
        const qty = Number(it.in_basket.quantity ?? it.quantity ?? 1);

        // Try to find a per-item display price
        const pObj = it.total_price || it.in_basket.price || it.base_price || it.unit_price || null;
        let amount = null;
        let currency = null;

        if (pObj && typeof pObj === "object") {
          amount = pObj.amount ?? pObj.value ?? null;
          currency = pObj.currency ?? pObj.currency_code ?? null;
        } else if (typeof pObj === "number") {
          amount = pObj;
        } else if (typeof pObj === "string" && pObj.trim() && !Number.isNaN(Number(pObj))) {
          amount = Number(pObj);
        } else if (typeof pObj === "string" && pObj.trim()) {
          // already formatted string
          amount = pObj;
        }

        return { id, name, qty, amount, currency };
      }).filter(x => x.id != null);
    }

    function renderCart(basket) {
      const list = $("cart-list");
      const totalEl = $("cart-total");
      const hint = $("cart-hint");

      list.innerHTML = "";

      if (!basket) {
        totalEl.textContent = "—";
        hint.textContent = "Add something to your cart to enable checkout.";
        return;
      }

      const items = normalizeCartItems(basket);
      const total = extractBasketTotal(basket);

      totalEl.textContent = formatMoney(total.amount, total.currency);
      hint.textContent = items.length ? "Ready when you are." : "Your cart is empty.";

      if (!items.length) return;

      items.forEach((it) => {
        const row = document.createElement("div");
        row.className = "cart-item";
        row.innerHTML = `
          <div>
            <div class="name">${safeText(it.name)}</div>
            <div class="meta">ID: ${it.id}</div>
          </div>

          <div class="cart-right">
            <span class="price-pill">${formatMoney(it.amount * it.qty, it.currency || total.currency)}</span>

            <div class="qty">
              <button class="qty-btn" type="button" data-qty-minus="${it.id}">-</button>
              <input class="qty-input" type="number" min="1" max="99" step="1" value="${it.qty}" data-qty-input="${it.id}" />
              <button class="qty-btn" type="button" data-qty-plus="${it.id}">+</button>
            </div>

            <button class="btn" type="button" data-remove="${it.id}">Remove</button>
          </div>
        `;
        list.appendChild(row);
      });

      // bind remove
      list.querySelectorAll("[data-remove]").forEach((btn) => {
        btn.addEventListener("click", async () => {
          btn.disabled = true;
          try {
            await removePackageFromBasket(btn.getAttribute("data-remove"));
          } catch (e) {
            alert(`Remove failed: ${e.message || e}`);
          } finally {
            btn.disabled = false;
          }
        });
      });

      // bind qty +/- and input
      function scheduleQtyUpdate(packageId, newQty) {
        const id = String(packageId);
        const q = Math.max(1, Math.min(99, Number(newQty) || 1));

        if (qtyUpdateTimers.has(id)) clearTimeout(qtyUpdateTimers.get(id));
        qtyUpdateTimers.set(id, setTimeout(async () => {
          const input = list.querySelector(`[data-qty-input="${CSS.escape(id)}"]`);
          if (input) input.disabled = true;
          try {
            await updatePackageQuantity(id, q);
          } catch { /* alert already shown */ }
          finally {
            if (input) input.disabled = false;
          }
        }, 350));
      }

      list.querySelectorAll("[data-qty-minus]").forEach((btn) => {
        btn.addEventListener("click", () => {
          const id = btn.getAttribute("data-qty-minus");
          const input = list.querySelector(`[data-qty-input="${CSS.escape(id)}"]`);
          const cur = Number(input?.value || 1);
          const next = Math.max(1, cur - 1);
          if (input) input.value = String(next);
          scheduleQtyUpdate(id, next);
        });
      });

      list.querySelectorAll("[data-qty-plus]").forEach((btn) => {
        btn.addEventListener("click", () => {
          const id = btn.getAttribute("data-qty-plus");
          const input = list.querySelector(`[data-qty-input="${CSS.escape(id)}"]`);
          const cur = Number(input?.value || 1);
          const next = Math.min(99, cur + 1);
          if (input) input.value = String(next);
          scheduleQtyUpdate(id, next);
        });
      });

      list.querySelectorAll("[data-qty-input]").forEach((input) => {
        input.addEventListener("input", () => {
          const id = input.getAttribute("data-qty-input");
          scheduleQtyUpdate(id, input.value);
        });
        input.addEventListener("blur", () => {
          const id = input.getAttribute("data-qty-input");
          const q = Math.max(1, Math.min(99, Number(input.value) || 1));
          input.value = String(q);
          scheduleQtyUpdate(id, q);
        });
      });
    }

    async function refreshCart() {
      if (!state.basketIdent) {
        renderCart(null);
        return null;
      }

      try {
        const basket = await fetchBasket();

        // update usernameId if present
        const uid = basket?.username_id || basket?.usernameId || "";
        if (uid && uid !== state.usernameId) {
          state.usernameId = uid;
          saveState();
          setStatus(`Basket: ${state.basketIdent} (user linked)`);
        } else {
          setStatus(`Basket: ${state.basketIdent}${state.usernameId ? ` (user linked)` : ""}`);
        }

        renderCart(basket);
        const totalItems = normalizeCartItems(basket).reduce((sum, it) => sum + it.qty, 0);
        document.querySelector(".total-item-count").textContent = String(totalItems);
        return basket;
      } catch {
        renderCart(null);
        return null;
      }
    }

    async function loadListings() {
      const data = await apiJson(`${API_BASE}/categories?includePackages=1`);
      const grid = $("product-grid");
      grid.innerHTML = "";

      (data?.data || []).forEach((cat) => {
        const catEl = document.createElement("div");
        catEl.className = "product-category ip";

        const packages = Array.isArray(cat?.packages) ? cat.packages : [];
        const packagesHtml = packages.map((pkg) => {
          console.log("Package:", pkg);
          const id = pkg?.id || pkg?.package_id;
          const desc = safeText(pkg?.description || "");
          const price = pickPackagePrice(pkg);
          const image = pkg?.image || pkg?.thumbnail_url || pkg?.thumbnailUrl || null;

          return `
            <div class="card span-3 package-card">
              <h4>${safeText(pkg?.name || "Package")}</h4>
              ${image ? `<img src="${image}" />` : ""}
              ${desc ? `<p class="muted" style="margin:0 0 10px;">${desc}</p>` : ""}
              <div class="package-actions">
                <span class="price-pill">${price ? formatMoney(price.amount, price.currency) : "See checkout"}</span>
                ${id ? `<button class="btn add-to-cart" type="button" data-buy="${id}">Add to cart</button>` : ""}
              </div>
            </div>
          `;
        }).join("");

        catEl.innerHTML = `
          <h2>${safeText(cat?.name || "Category")}</h2>
          ${cat?.description ? `${cat.description}` : ""}
          <div class="card-grid">${packagesHtml}</div>
        `;
        grid.appendChild(catEl);
      });

      document.querySelectorAll("[data-buy]").forEach((btn) => {
        btn.addEventListener("click", async () => {
          btn.disabled = true;
          try {
            await addPackageToBasket(btn.getAttribute("data-buy"));
          } catch (e) {
            alert(`Add to cart failed: ${e.message || e}`);
          } finally {
            btn.disabled = false;
          }
        });
      });
    }

    async function launchCheckout() {
      const basket = await ensureBasket();
      const refreshed = await refreshCart();

      const b = refreshed || basket;
      const itemsCount = (b?.packages?.length || b?.items?.length || 0);

      if (!itemsCount) {
        alert("Your cart is empty. Add a package first.");
        return;
      }

      // Tebex.js popup checkout
      Tebex.checkout.init({
        ident: state.basketIdent,
        theme: "dark",
        closeOnPaymentComplete: false,
        colors: [
          { name: "primary", color: "#7dd3fc" },
          { name: "secondary", color: "#a78bfa" }
        ]
      });

      Tebex.checkout.on("payment:complete", async () => {
        clearBasketLocal();
        // alert("Payment complete! Thanks for supporting ValhallaMC.");
      });

      Tebex.checkout.on("payment:error", (evt) => {
        console.warn("Payment error:", evt);
      });

      Tebex.checkout.launch();
    }

    window.addEventListener("load", async () => {
      // hydrate username input
      $("mc-username").value = state.username || "";

      // buttons
      $("btn-new-basket").addEventListener("click", async () => {
        try {
          const u = $("mc-username").value.trim();
          if (!u) return alert("Enter your Minecraft username first.");
          clearBasketLocal();
          await createBasket(u);
          await refreshCart();
        } catch (e) {
          alert(`Basket failed: ${e.message || e}`);
        }
      });

      $("btn-checkout").addEventListener("click", async () => {
        try {
          await launchCheckout();
        } catch (e) {
          alert(`Checkout failed: ${e.message || e}`);
        }
      });

      // load products + cart
      try {
        await refreshCart();
      } catch { /* ignore */ }

      try {
        await loadListings();
      } catch (e) {
        console.error("Error fetching listings:", e);
        alert(`Could not load shop listings: ${e.message || e}`);
      }
    });
    })
    .catch(error => {
      console.error("Error fetching token:", error);
    });
</script>

<footer>
  <script>
    fetch('components/footer.html')
      .then(response => response.text())
      .then(data => {
        const element = document.createElement('div');
        element.classList.add('footer-content', 'wrap');
        document.querySelector('footer').appendChild(element);
        element.innerHTML = data;

        const scripts = element.querySelectorAll('script');
        scripts.forEach(oldScript => {
          const newScript = document.createElement('script');
          Array.from(oldScript.attributes).forEach(attr =>
            newScript.setAttribute(attr.name, attr.value)
          );
          newScript.appendChild(document.createTextNode(oldScript.innerHTML));
          oldScript.parentNode.replaceChild(newScript, oldScript);
        });
      });
  </script>
</footer>

<script src="./globals.js"></script>
</body>
</html>